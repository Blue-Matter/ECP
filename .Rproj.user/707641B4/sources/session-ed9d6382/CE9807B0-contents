

is_Blow = function(MSEobj,MPind,PPDy,stockind=2){

  yind = MSEobj@nyears+11:30 # projection years 1:30 for Blim
  Blow = function(x)any(x<0.2) # half of Blim
  temp = MSEobj@B_BMSY[MPind,,stockind,yind] #  stocks
  apply(temp,1,Blow)

}

is_Blim = function(MSEobj,MPind,PPDy,stockind=2){

  yind = MSEobj@nyears+11:30 # projection years 1:30 for Blim
  Blow = function(x)any(x<0.4) # half of Blim
  temp = MSEobj@B_BMSY[MPind,,stockind,yind] #  stocks
  apply(temp,1,Blow)

}

Index_compiler<-function(dir=NULL,name=NULL, MPind=NULL, dummy_obs=T, First_Yr = 2020,dummycut=5){

  if(is.null(Indices))stop("You need to run loadABT()")

  files<-list.files(dir)
  isMSE<-grepl("MSE_",files)
  MSEref<-c(paste0("MSE_",1:48),paste0("MSE_R_",1:44))
  nOMs<-length(MSEref)
  fileref<-paste0(dir,MSEref,".rda")


  MSEobj= readRDS(fileref[1])
  if(length(MSEobj@PPD)==0) stop(paste0("There are no posterior predicted data in: ",fileref[1],". You need to run the MSEs with the argument returnMSE = T, see CMP dev guide"))
  if(is.null(MPind))MPind = length(MSEobj@PPD)

  Eastind = 1
  PPDi = MSEobj@PPD[[MPind]][[Eastind]]$Iobs # second tier is stock and that is identical in terms of index reporting - same indices are available to both stocks
  idims = dim(PPDi)

  lastYr = 2019
  nsim = idims[1]
  nind = idims[2]
  PPDy = idims[3]
  yind = (MSEobj@nyears+1):PPDy
  npy=length(yind)
  Yrs = lastYr + 1: npy

  PPD = array(NA,c(nsim,nOMs,nind,npy))
  npow=5
  Pow = array(F,c(nsim,nOMs,npow))

  # fileref = rep(fileref[1:48],20)[1:nOMs]

  for(OM in 1:nOMs){
    MSEobj<-readRDS(fileref[OM])
    PPDi = MSEobj@PPD[[MPind]][[Eastind]]$Iobs # second tier is stock and that is identical in terms of index reporting - same indices are available to both stocks
    PPD[,OM,,] = PPDi[,,yind]
    Pow[,OM,1]= is_Blow(MSEobj,MPind,PPDy,stockind=1)
    Pow[,OM,2]= is_Blow(MSEobj,MPind,PPDy,stockind=2)
    Pow[,OM,3]= is_Blow(MSEobj,MPind,PPDy,stockind=1:2)
    Pow[,OM,4]= is_Blim(MSEobj,MPind,PPDy,stockind=1)
    Pow[,OM,5]= is_Blim(MSEobj,MPind,PPDy,stockind=2)
  }

  DesignRef = ABTMSE::Design$Design_Ref
  # ref OMs default: 1L, 2L, 1L, 2L.

  ROMind = c(rep(c(1,2,4,5),8),c(3,6,3,6),rep(c(1,2,4,5),2))
  Design = rbind(DesignRef, DesignRef[ROMind,])
  Design = cbind(Design,c(rep("Ref",48),rep("Rob",44)))
  names(Design) = c("Recruitment","Mat_M","Scale","CompWt","Ref_Rob")
  row.names(Design) = 1:nrow(Design)

  dimnames(PPD)[[1]] = dimnames(Pow)[[1]] = paste0("Sim_",1:48)
  dimnames(PPD)[[2]] = dimnames(Pow)[[2]] = c(paste0("Ref_",1:48),paste0("Rob_",1:44))
  dimnames(PPD)[[3]] = Indices$Name
  dimnames(PPD)[[4]] = Yrs
  dimnames(Pow)[[3]] = c("E 1/2 Blim","W 1/2 Blim","EorW 1/2 Blim", "E Blim", "W Blim")

  Data_Design = rep("Index",nind)

  # Set up default selections
  Defaults = list()

  OM_def = as.list(apply(Design,2,function(x){unique(x)}))
  OM_def[[5]] = "Ref"
  OM_defE = OM_def
  OM_defE[[1]] = c(3) # Eastern ECP is rec lev 3

  Defaults[[1]] = list(c(1,2,3,4,5,6,10,12,13,14), 1:8, OM_def,  0.05,   NaN, "interval") # Generic default ECP - all input indices
  Defaults[[2]] = list(16,                         1:8, OM_def,  0.0365, 2,   "LB")         # Preliminary western ECP - all input indices
  Defaults[[3]] = list(c(2,16),                    1:8, OM_defE, 0.018,  1,   "auto")       # Preliminary eastern ECP - all input indices only rec lev 3

  for(i in 1:3) names(Defaults[[i]]) = c("Data","yind","OM","alph","powind","tail")
  names(Defaults)=c("Standard","Western prelim.","Eastern prelim.")

  Obs = PPD[1,1,,]
  if(dummy_obs)  Obs[,dummycut:npy] = NA
  if(!dummy_obs) Obs[] = NA

  return(list(PPD=PPD, OM_Design=Design, Defaults = Defaults, Obs = Obs, Pow=Pow,
         First_Yr = First_Yr, Version = packageVersion('ABTMSE'),Sys.time=Sys.time()))

  # ECP_obj = list(PPD=PPD, OM_Design=Design, Defaults = Defaults, Obs = Obs, Pow=Pow, First_Yr = First_Yr, Version = packageVersion('ABTMSE'),Sys.time=Sys.time())


}

slp4<-function(y){
  x1<-1:length(y)
  x1 <- x1[!is.na(y)]
  y<-y[!is.na(y)]
  y<-log(y)
  mux<-mean(x1)
  muy<-mean(y,na.rm=T)
  SS<-sum((x1-mux)^2,na.rm=T)
  (1/SS)*sum((x1-mux)*(y-muy),na.rm=T)

}

Append_Comp_Ind = function(ECP_obj,
                           Igroups = list(ECI = c(1,2,4,5,6),
                                          WCI = c(3,13,14,10,12)),
                           Iwts = list(ECI = c(1.33,1.66,1.06,1.43,1.33),
                                       WCI = c(1.33,2.55,1.39,3.96,2.88))){

  ECP_nu = ECP_obj
  PPD = ECP_obj$PPD

  #rownames(ECP_obj$Obs)
  dims = dim(PPD)
  nsim = dims[1]
  nOM = dims[2]
  nI = dims[3]
  ny = dims[4]
  ng = length(Igroups)

  nu_obs = array(NA,c(ng,ny))
  nu_PPD = array(NA,c(nsim, nOM, ng, ny))
  dimnames(nu_PPD)[[3]] = rownames(nu_obs)= names(Igroups)
  for(i in c(1,2,4))dimnames(nu_PPD)[[i]]=dimnames(PPD)[[i]]
  colnames(nu_obs)=colnames(ECP_obj$Obs)

  for(gg in 1:ng){
    for(yy in 1:ny){
      nu_obs[gg,yy] = weighted.mean(ECP_obj$Obs[Igroups[[gg]],yy],Iwts[[gg]])
      for(i in 1:nsim){
        for(OM in 1:nOM){
          nu_PPD[i,OM,gg,yy] =  weighted.mean(PPD[i,OM,Igroups[[gg]],yy],Iwts[[gg]])
        }
      }
      cat(yy);cat(" - ")
    }
  }
  cat('\n')

  ECP_nu$PPD = abind(ECP_obj$PPD, nu_PPD, along=3)
  ECP_nu$Obs = rbind(ECP_nu$Obs, nu_obs )
  #ECP_nu$Defaults$Data = c(ECP_obj$Defaults$Data, dim(ECP_obj$Obs)[1] + ECP_obj$Defaults$Data)
  ECP_nu

}

Append_Index_Slopes = function(ECP_obj){

  ECP_nu = ECP_obj
  obslp = apply(ECP_obj$Obs[,1:4],1,slp4)

  obsmat = array(NA,dim(ECP_obj$Obs))
  obsmat[,4] = obslp
  dimnames(obsmat)[[2]] = dimnames(ECP_obj$Obs)[[2]]
  dimnames(obsmat)[[1]] = paste0("Slp_",dimnames(ECP_obj$Obs)[[1]])

  ECP_nu$Obs = rbind(ECP_obj$Obs,obsmat)

  predmat = array(NA, dim(ECP_obj$PPD))
  ny = dim(ECP_obj$PPD)[4]

  for(y in 3:ny){
    predmat[,,,y] = apply(ECP_obj$PPD[,,,(y-2):y],1:3,slp4)
    cat(paste(y,"- "))
  }
  cat("\n")
  dimnames(predmat) = dimnames(ECP_obj$PPD)
  dimnames(predmat)[[3]] = paste0("Slp_",dimnames(ECP_obj$PPD)[[3]])

  ECP_nu$PPD = abind(ECP_obj$PPD,predmat,along=3)
  #ECP_nu$Defaults$Data = c(ECP_obj$Defaults$Data, dim(ECP_obj$Obs)[1] + ECP_obj$Defaults$Data)
  ECP_nu

}

Append_SOO = function(ECP_obj, dir = "C:/temp2/ECP2/",
                      OMdirs =paste0("C:/Users/tcar_/Dropbox/abft-mse/objects/OMs/",c(1:48,c(rep(c(1,2,4,5),8),c(3,6,3,6),rep(c(1,2,4,5),2)))),
                      OMIs = paste0("OMI_",c(1:48,c(rep(c(1,2,4,5),8),c(3,6,3,6),rep(c(1,2,4,5),2)))),
                      dummy_obs=T,MPind=NULL){

  files<-list.files(dir)
  isMSE<-grepl("MSE_",files)
  MSEref<-c(paste0("MSE_",1:48),paste0("MSE_R_",1:44))
  nOMs<-length(MSEref)
  fileref<-paste0(dir,MSEref,".rda")

  MSEobj= readRDS(fileref[1])
  if(length(MSEobj@PPD)==0) stop(paste0("There are no posterior predicted data in: ",fileref[1],". You need to run the MSEs with the argument returnMSE = T, see CMP dev guide"))
  if(is.null(MPind))MPind = length(MSEobj@PPD)

  Eastind = 1
  PPDi = MSEobj@PPD[[MPind]][[Eastind]]$Iobs # second tier is stock and that is identical in terms of index reporting - same indices are available to both stocks
  idims = dim(PPDi)

  lastYr = 2019
  nsim = idims[1]
  nind = 8 # WATL ac23 season#, GSL 123, NATL 123 EATL SOO by age class
  PPDy = idims[3]
  yind = (MSEobj@nyears+1):PPDy
  npy=length(yind)
  Yrs = lastYr + 1: npy
  PPD = array(NA,c(nsim,nOMs,nind,npy))
  #as = c(2,3,5,6) # WATL, GSL, NATL, EATL

  set.seed(1)
  sfInit(parallel=T,cpus=8)
  sfLibrary(ABTMSE)
  OMIex<-paste0("OMI_",1:48)
  sfExport(list=as.list(OMIex)) # OMs are the actual objects

  getSOOobs = function(OM,fileref,OMdirs,OMIs,MPind,nsim,npy,yind){
    #for(OM in 1:nOMs){
    ilogit = function(x)exp(x)/(1+exp(x))
    logit = function(x)log(x/(1-x))

    MSEobj<-readRDS(fileref[OM])
    out =  M3read(OMDir=OMdirs[OM])
    OMI = get(OMIs[OM])
    SOOobs = OMI@SOOobs
    names(SOOobs) =  c("a",  "y", "s", "r",   "N", "probE",  "SE", "Type", "wt")
    SOOpred = out$SOOpred
    CTA = MSEobj@CTA[MPind,,,,,] #  48   3 109   4   7

    err = array(NA,c(nsim,8,npy))
    j = 0
    for(ac in 2:3){
      for(ss in 1:4){
        SOOind = SOOobs[,1] == ac & SOOobs[,3] == ss & SOOobs[,4]==2
        SOOo = SOOobs[SOOind,6]
        SOOp = SOOpred[SOOind]
        SD = sd(SOOo-SOOp) # log sd
        #SD=1
        j=j+1
        err[,j,] = logit(CTA[,ac,yind,ss,2])*array(rnorm(nsim*npy,0,SD),c(nsim,npy))
        #print(paste(ac,"-",ss,"-",length(SOOp),"-",SD))


      }
    }
    #cat(OM);cat("-")
    err
  }

  errs = sfLapply(1:nOMs,getSOOobs,fileref=fileref,OMdirs=OMdirs,OMIs=OMIs,MPind=MPind,nsim=nsim,npy=npy,yind=yind)
  for(OM in 1:nOMs)  PPD[,OM,,] = errs[[OM]]#logit(CTA[,ac,yind,ss,2])*err # area 2 is WATL

  dimnames(PPD)[[1]] = paste0("Sim_",1:48)
  dimnames(PPD)[[2]] = c(paste0("Ref_",1:48),paste0("Rob_",1:44))
  dimnames(PPD)[[3]] = paste0("WATL_SOO_a",rep(2:3,each=4),"_q",rep(1:4,2))
  dimnames(PPD)[[4]] = Yrs

  ECP_nu = ECP_obj

  obsmat=PPD[1,1,,]
  if(dummy_obs)obsmat[,5:npy] = NA
  if(!dummy_obs)obsmat[] = NA

  ECP_nu$Obs = rbind(ECP_obj$Obs,obsmat)

  ECP_nu$PPD = abind(ECP_obj$PPD,PPD,along=3)
  #ECP_nu$Defaults$Data = c(ECP_obj$Defaults$Data, dim(ECP_obj$Obs)[1] + 1:nind)
  ECP_nu

}


PPD_qplot = function(qs, Obs, Yrs, col, tcol = "red",tl = 2, tu = 7){

  ylim = range(qs,Obs,na.rm=T)
  matplot(Yrs,t(qs),col="white",ylim=ylim,xlab="",ylab="");  grid()
  nq = nrow(qs)
  keep=!is.na(qs[1,])
  for(i in 1:(nq/2))  polygon(c(Yrs[keep],rev(Yrs[keep])),c(qs[i,keep],rev(qs[nq-i+1,keep])),col=col,border=NA)
  no = length(Obs)
  pcols = rep('black',no);
  ppch = rep(19,no); plwd=rep(1,no)
  condsim = apply(qs,2,sd)>0.01
  ppch[condsim] = 3; plwd[condsim]=3
  cond = Obs < qs[tl,] | Obs > qs[tu,]
  pcols[cond] = "red";  ppch[cond] = 3; plwd[cond]=3
  points(Yrs, Obs, col=pcols, pch=ppch, lwd=plwd)

}


# OMind = 1:48; Iind = 1; yind = 1:9

PPD_Proj = function(ECP_obj, Iplot = 1, OMind = 1:48, yind = 1:9,col,donam=T){

  PPD = ECP_obj$PPD
  ints = c(99,95,90,50)
  lps = ((100-ints)/2)/100
  ps = c(lps, rev(1-lps))

  qs = apply(PPD[,OMind,Iplot,yind,drop=F],4,quantile,p=ps,na.rm=T)
  Yrs = ECP_obj$First_Yr-1+yind
  Obs = ECP_obj$Obs[Iplot,yind]

  PPD_qplot(qs, Obs, Yrs, col=col)
  if(donam)mtext(dimnames(PPD)[[3]][Iplot],line=0.4,font=2,cex=0.85)

}

plot_marg_dens=function(ECP_obj,OMind=1:48, Iind=NULL,yind=1:7, col="#0000ff20"){
  if(is.null(Iind))Iind=ECP_obj$Defaults$Data

  ni = length(Iind)+1
  nc=ceiling(ni^0.5)
  nr=ceiling(ni/nc)
  par(mfrow=c(nr,nc),mai=c(0.3,0.3,0.35,0.025),omi=c(0.3,0.3,0,0))
  for(i in 1:(ni-1))PPD_Proj(ECP_obj, Iplot = Iind[i], OMind = OMind, yind = yind,col=col)
  for(i in 1:((nr*nc)-ni+1))plot(1,1,col="white",xlab="",ylab="",axes=F,main="")
  coly = paste0("#0000ff",c(20,30,40,80))
  legend('left',fill = coly,cex=1.1,legend = c("99%","95%","90%","50%"),title = "Int. rng.",bty='n',border=coly)
  legend('right', pch = c(19,3,3),col=c('black','black','red'),cex=1.1,
         legend = c("Conditioning","Projection","Triggered"),title = "Obs. Data",bty='n')

  mtext('Year',1,line=0.5,outer=T,font=2)
  mtext('Index value',2,line=0.5,outer=T,font=2)

}



dens_Proj = function(ECP_obj, Iplot = 1, OMind = 1:48, yind = 1:6,col,donam=T){

  PPD = ECP_obj$PPD[,OMind,Iplot,yind,drop=F]
  nsim=dim(PPD)[1]
  ystoplot = yind[apply(PPD,4,function(x){length(unique(as.vector(x)))>(nsim-1)})]
  Yrs = ECP_obj$First_Yr-1+yind
  Obs = ECP_obj$Obs[Iplot,yind]
  qs=apply(PPD[,,,yind],3,quantile,p=0.95,na.rm=T)
  plot(c(min(Yrs),max(Yrs)+1),c(0,max(qs,na.rm=T)),col='white',xlab="",ylab="")

  for(yy in yind){
    if(yy %in% ystoplot){
      vec = as.vector(PPD[,,,yy])
      dens=density(vec,from=0)
      ys = 0.95*(dens$y / max(dens$y))
      polygon(Yrs[yy]+ys,dens$x,col='#0000ff90',border=NA)
    }
    if(!is.na(Obs[yy])) lines(Yrs[yy]+c(0,0.95),rep(Obs[yy],2),lwd=3)
  }

  if(donam)mtext(dimnames(PPD)[[3]],line=0.4,font=2,cex=0.85)

}


getcrit = function(vec,vecalt,tail,alp){

  if(tail=="UB"){
    crit = quantile(vec,1-alp,na.rm=T)
    T2 = mean(vecalt<crit,na.rm=T)
  }else if(tail=="LB"){
    crit = quantile(vec,alp,na.rm=T)
    T2 = mean(vecalt>crit,na.rm=T)
  }else{
    crit = quantile(vec,c(alp/2,1-(alp/2)),na.rm=T)
    T2 = mean(vecalt>crit[1]&vecalt<crit[2],na.rm=T)
  }
  list(crit=crit,T2 = T2)

}

dens_Proj_pow = function(ECP_obj, Iplot = 1, OMind = 1:48, yind = 1:8,col,donam=T,powind=1,tail="LB",alp=0.025,fraclab=F){

  PPD = ECP_obj$PPD[,OMind,Iplot,yind,drop=F]
  nsim=dim(PPD)[1]
  ystoplot = yind[apply(PPD,4,function(x){length(unique(as.vector(x)))>(nsim-1)})]
  Yrs = ECP_obj$First_Yr-1+yind
  Obs = ECP_obj$Obs[Iplot,yind]
  qs=apply(PPD[,,,yind],3,quantile,p=c(0.001,0.999),na.rm=T)
  T2textlev = min(qs,na.rm=T)+(max(qs,na.rm=T)-min(qs,na.rm=T))*0.92

  plot(c(min(Yrs),max(Yrs)+1),range(qs,na.rm=T),col='white',xlab="",ylab="")
  pow = array(ECP_obj$Pow[,OMind,powind],dim(PPD))
  if(fraclab)legend('topleft',legend=paste("% alt =",round(mean(pow)*100,1)),bty="n",cex=0.9)

  for(yy in yind){
    if(yy %in% ystoplot){
      PPDy = PPD[,,,yy]
      vecnull =as.vector(PPDy[!pow])# as.vector(PPDy[!pow])
      vecalt = as.vector(PPDy[pow])
      out = getcrit(vecnull,vecalt,tail,alp)
      crit=out[[1]]

      densnull=density(vecnull,na.rm=T)
      ysnull = 0.95*(densnull$y / max(densnull$y))
      for(i in 1:length(crit))lines(Yrs[yy]+c(0,0.95),rep(crit[i],2),col="blue",lty=1)

      densalt=density(vecalt,na.rm=T)
      ysalt = 0.95*(densalt$y / max(densalt$y))

      polygon(Yrs[yy]+ysnull,densnull$x,col='#0000ff90', border=NA)
      polygon(Yrs[yy]+ysalt, densalt$x, col='#ff000090', border=NA)

      #text(Yrs[yy]+0.6,quantile(vecalt,0.99,na.rm=T),round(out[[2]]*100,0),col="red",cex=0.8)
      text(Yrs[yy]+0.6,T2textlev,round(out[[2]]*100,0),col="red",cex=0.8,srt=-90)
    }
    if(!is.na(Obs[yy])) lines(Yrs[yy]+c(0,0.95),rep(Obs[yy],2),lwd=3)
  }

  if(donam)mtext(dimnames(PPD)[[3]],line=0.4,font=2,cex=0.75)

}

plot_dist=function(ECP_obj,OMind=1:48, Iind=NULL,yind=1:8,powind=1,tail="LB",alp=0.025){

  if(tail[1]=="auto")tail=autotail(ECP_obj, OMind, Iind, yind, powind)
  if(length(tail)==1)tail=rep(tail,length(Iind))

  if(is.null(Iind))Iind=ECP_obj$Defaults$Data
  ni = length(Iind)+1
  nc=ceiling(ni^0.5)
  nr=ceiling(ni/nc)
  par(mfrow=c(nr,nc),mai=c(0.25,0.3,0.3,0.025),omi=c(0.15,0.1,0,0))

  for(i in 1:(ni-1)){
    if(is.null(powind)){
      dens_Proj(ECP_obj, Iplot = Iind[i], OMind = OMind, yind = yind,col=col,fraclab=(i==1))
    }else{
      dens_Proj_pow(ECP_obj, Iplot = Iind[i], OMind = OMind, yind = yind,col=col,powind=powind,tail=tail[i],alp=alp,fraclab=(i==1))
    }
  }

  for(i in 1:((nr*nc)-ni+1))plot(1,1,col="white",xlab="",ylab="",axes=F,main="")
  if(is.null(powind))legend('center',cex=1.1,legend = c("Predicted","Observed"),text.col=c("#0000ff95",'black'),text.font=2,bty='n')
  if(!is.null(powind))legend('center',cex=1.1,legend = c("Null","Alternative","Observed"),text.col=c("#0000ff95","#ff000095",'black'),text.font=2,bty='n')
}


do_stz=function(ECP_obj,Iind,OMind){

  PPDs0=ECP_obj$PPD[,OMind,Iind,,drop=F]
  obs0 = ECP_obj$Obs[Iind,,drop=F]

  # log if all positive
  for(i in 1:length(Iind)){
    if(all(PPDs0[,,i,]>0,na.rm=T)){
      PPDs0[,,i,]=log(PPDs0[,,i,])
      obs0[i,]=log(obs0[i,])
    }
  }
  PPDs1 = PPDs2 = PPDs0

  dims = dim(PPDs0)
  sds=apply(PPDs0,3:4,sd)
  mus=apply(PPDs0,3:4,mean)
  PPDs1 = PPDs0-array(rep(mus,each=prod(dims[1:2])),dims)
  PPDs2 = PPDs1/array(rep(sds,each=prod(dims[1:2])),dims)
  obs2 = (obs0-mus)/sds

  ni=length(Iind)
  for(i in 1:ni){
    PD = PPDs2[,,i,]
    Ob = obs2[i,]
    makeNA = !(PD[1,1,]!=0 & !is.na(PD[1,1,]) & !is.na(Ob))
    PPDs2[,,i,makeNA]= NA
    obs2[i,makeNA] = NA
  }

  list(PPDs = PPDs2,Obss = obs2)

}

PPD_qplot_stz = function(ps, qs,Obss, Yrs, yind, col){

  ylim = range(qs,Obss,na.rm=T)
  matplot(Yrs,t(qs),col="white",ylim=ylim,xlab="",ylab="") #;  grid()
  #abline(h=0,lty=2)
  refs = qnorm(ps,0,1)
  #abline(h=refs,lty=2)

  np = length(ps)
  ny=length(Yrs)
  #keep=!is.na(qs[1,])
  #for(i in 1:(nq/2))  polygon(c(Yrs[keep],rev(Yrs[keep])),c(qs[i,keep],rev(qs[nq-i+1,keep])),col=col,border=NA)
  for(i in 1:(np/2))  polygon(c(Yrs,rev(Yrs)),c(rep(refs[i],ny),rep(refs[np-i+1],ny)),col=col,border=NA)

  ni=nrow(Obss)
  pchs = rep(c(1,3,6,18),each = 4)
  cols = rep(c("black","red","green","blue"),4)
  for(i in 1:ni){
    ob1 = Obss[i,yind]
    ys = (1:length(ob1))[!is.na(ob1)]
    points(Yrs,ob1,col=cols[i],pch=pchs[i],cex=1.25,lwd=3)
    lines(Yrs,ob1,col=cols[i])
    hasval=!is.na(ob1)
    maxy = max(Yrs[hasval])
    lastob = ob1[match(maxy,Yrs)]
    text(maxy+1,lastob,dimnames(Obss)[[1]][i],col=cols[i],font=2,cex=0.9)
  }

}

PPD_stz = function(PPDs, Obss, yind = 2:6, col){
  ints = c(99,95,90,50)
  lps = ((100-ints)/2)/100
  ps = c(lps, rev(1-lps))
  qs = apply(PPDs[,,,yind, drop=F], 4, quantile, p=ps, na.rm=T)
  Yrs = ECP_obj$First_Yr-1 + yind
 ints = c(99,95,90,50)
  lps = ((100-ints)/2)/100
  ps = c(lps, rev(1-lps))
  qs = apply(PPDs[,,,yind, drop=F], 4, quantile, p=ps, na.rm=T)
  Yrs = ECP_obj$First_Yr-1 + yind
  PPD_qplot_stz(ps, qs,Obss, Yrs, yind, col=col)
  PPD_qplot_stz(ps, qs,Obss, Yrs, yind, col=col)
}

plot_all_marg_dens=function(ECP_obj,OMind=1:48, Iind=NULL,yind=2:6, col="#0000ff20"){

  layout(matrix(c(1,2),nrow=1),widths=c(1,0.35))
  par(mai=c(0.8,0.8,0.01,0.01))
  if(is.null(Iind))Iind=ECP_obj$Defaults$Data
  stz = do_stz(ECP_obj,Iind,OMind)
  PPD_stz(PPDs = stz$PPDs,Obss = stz$Obss,yind,col)
  mtext('Year',1,line=2.5,outer=F,font=2)
  mtext('Standardized log index value',2,line=2.5,outer=F,font=2)
  plot(1,1,col="white",xlab="",ylab="",axes=F,main="")
  coly = paste0("#0000ff",c(20,30,40,80))
  legend('center',fill = coly,cex=0.9,legend = c("99%","95%","90%","50%"),title = "Interquant. rng.",bty='n',border=coly)

}

# Multivariate ECP

mahalanobis_robust<-function (x, center, cov, inverted = FALSE) {

  x <- if (is.vector(x)){
    matrix(x, ncol = length(x))
  } else {
    as.matrix(x)
  }
  if (!identical(center, FALSE)) x <- sweep(x, 2L, center)

  invcov <- corpcor::pseudoinverse(cov)
  setNames(rowSums(x %*% invcov * x), rownames(x))

}

getsegment<-function(densobj,thresh,lower=T){
  if(lower){
    cond<-densobj$x<thresh
  }else{
    cond<-densobj$x>thresh
  }

  xs<-c(0,densobj$y[cond],0)
  ys<-densobj$x[cond]
  ys<-c(ys[1],ys,ys[length(ys)])

  list(x=xs,y=ys)
}


get_pred_sim=function(ECP_obj,OMind,Iind,powind=1){

  Obs = ECP_obj$Obs[Iind,,drop=F]
  PPD = ECP_obj$PPD[,OMind,Iind,]
  nsim = dim(PPD)[1]
  nd = dim(PPD)[3]
  ny = dim(PPD)[4]
  nOM = length(OMind)
  varfunc = function(x)sd(x)>0.00001 & !is.na(sd(x))
  add2calc = apply(PPD[,1,,],2:3,varfunc)&!is.na(Obs)
  ys = array(rep(1:ny,each=nd),c(nd,ny))[add2calc]
  ds = array(rep(1:nd,ny),c(nd,ny))[add2calc]
  ndat=sum(add2calc)
  preds = array(NA,c(nsim*nOM,ndat))
  obs = rep(NA,ndat)
  for(i in 1:ndat){
    normswitch = any(PPD[,,ds[i],ys[i]]<0)
    if(normswitch){
      preds[,i] = as.vector(PPD[,,ds[i],ys[i]])
      obs[i] =Obs[ds[i],ys[i]]
    }else{
      preds[,i] = log(as.vector(PPD[,,ds[i],ys[i]]))
      obs[i] =log(Obs[ds[i],ys[i]])

    }
  }

  pows=as.vector(ECP_obj$Pow[,OMind,powind])

  Inams = 1:length(dimnames(PPD)[[3]])
  nams = paste0(Inams[ds],"_",ys+ECP_obj$First_Yr-1)

  yrs= min(ys+ECP_obj$First_Yr-1):max(ys+ECP_obj$First_Yr-1)
  list(preds=preds,obs=obs,nams=nams,pows=pows,yrs=yrs)
}

get_pred_sim_yr=function(ECP_obj,OMind,Iind,yind=1:6,powind=1){
  PPD = ECP_obj$PPD[,OMind,Iind,yind,drop=F]
  Obs = ECP_obj$Obs[,yind]
  nsim = dim(PPD)[1]
  nd = dim(PPD)[3]
  ny = dim(PPD)[4]
  nOM = length(OMind)
  varfunc = function(x)sd(x)>0.00001 & !is.na(sd(x))
  add2calc = apply(PPD[,1,,,drop=F],3:4,varfunc)
  ys = array(rep(1:ny,each=nd),c(nd,ny))[add2calc]
  ds = array(rep(1:nd,ny),c(nd,ny))[add2calc]
  ndat=sum(add2calc)
  preds = array(NA,c(nsim*nOM,ndat))
  obs = rep(NA,ndat)
  for(i in 1:ndat){
    normswitch = any(PPD[,,ds[i],ys[i]]<0)
    if(normswitch){
      preds[,i] = as.vector(PPD[,,ds[i],ys[i]])
      obs[i] =Obs[ds[i],ys[i]]
    }else{
      preds[,i] = log(as.vector(PPD[,,ds[i],ys[i]]))
      obs[i] =log(Obs[ds[i],ys[i]])

    }
  }
  pows=as.vector(ECP_obj$Pow[,OMind,powind])
  Inams = 1:length(dimnames(PPD)[[3]])
  nams = paste0(Inams[ds],"_",ys+ECP_obj$First_Yr-1)
  yrs=ECP_obj$First_Yr+yind-1
  list(preds=preds,obs=obs,nams=nams,pows=pows,yrs=yrs)
}

# alpha=0.05; OMind = 1:48
plot_mdist<-function(ECP_obj,alp=0.05, OMind = 1:48, Iind=NULL, yind=1:6){

  if(is.null(Iind))Iind=ECP_obj$Defaults$Data

  out=get_pred_sim(ECP_obj,OMind,Iind)

  preds=out$preds
  obs=out$obs

  nullcov<-cov(preds)
  nullm<-apply(preds,2,mean,na.rm=T)

  dist<-mahalanobis_robust(x=obs, center=nullm, cov=nullcov)
  dists<-mahalanobis_robust(x=preds, center=nullm, cov=nullcov)

  xlim=c(min(dist*0.95,quantile(dists,0.0005)),max(dist*1.05,quantile(dists,0.9995)))
  par(mfrow=c(1,1),mai=c(0.7,0.7,0.5,0.05))
  dens<-density(dists,from=0,to=xlim[2])

  plot(dens,xlab="",main="",col='white',ylab="",xlim=xlim); grid()
  lines(dens,xlab="",main="",col='blue')
  thresh<-quantile(dists,1-alp)
  abline(v=thresh,lty=2,lwd=2,col='orange')

  cex = 0.85
  text(thresh+0.5*(xlim[2]-thresh),max(dens$y)*0.9,paste0("V"),cex=cex,col="orange")
  text(dist+0.4*(xlim[2]-dist),max(dens$y)*0.97,"D (observed data)",font=2,cex=cex,col="black")

  mtext("Multivariate distance",1,line=2)
  mtext("Density",2,line=2)
  subdens<-getsegment(dens,thresh,lower=F)
  polygon(y=subdens$x,x=subdens$y,col="#0000ff95",border=NA)

  leg<-"Outlier detected (D > V)"
  lcol<-"Red"
  if(dist<thresh){
    leg<-"Outlier not detected (D < V)"
    lcol="darkgreen"
  }

  abline(v=dist,lwd=2,col="black")

  legend('topleft',legend=c(paste0("Critical value = ",round(thresh,2)),
                          paste0("Test statistic = ",round(dist,2))),
         text.col=c('orange','black'),cex=0.8,bty='n')


  cex = 0.85
  legend('right',legend=paste("Type I err = ",round(alp*100,1),"%"),
                          ,
         fill="#0000ff95", border="#0000ff95",bty='n',cex=cex)

  mtext(leg,col=lcol,3,line=0.2,font=2)

}

encircle2<-function (x, y, col = "red", perc = 0.05, xrange = NA,
                     yrange = NA, log = F, lty = 1, lwd = 1, labels = NA, drawlabels = F)
{
  if (!requireNamespace("MASS", quietly = TRUE)) {
    stop("Package \"MASS\" needed for this function to work. Please install it.",
         call. = FALSE)
  }
  nsim <- length(x)
  if (log) {
    x <- log(x)
    y <- log(y)
  }
  if (is.na(xrange[1]))
    xrange <- range(x)
  if (is.na(yrange[1]))
    yrange <- range(y)
  if (log) {
    xrange[xrange == 0] <- 0.01
    yrange[yrange == 0] <- 0.01
    xrange <- log(xrange)
    yrange <- log(yrange)
  }
  kerneld <- MASS::kde2d(x, y, n = 100, lims = c(xrange, yrange))
  pp <- array()
  for (i in 1:nsim) {
    z.x <- max(which(kerneld$x < x[i]))
    z.y <- max(which(kerneld$y < y[i]))
    pp[i] <- kerneld$z[z.x, z.y]
  }
  confidencebound <- quantile(pp, perc, na.rm = TRUE)
  if (log) {
    kerneld$x <- exp(kerneld$x)
    kerneld$y <- exp(kerneld$y)
  }
  if (is.na(labels)) {
    contour(kerneld, levels = confidencebound, col = col,
            add = TRUE, drawlabels = drawlabels, lty = lty, lwd = lwd)
  }
  else {
    contour(kerneld, levels = confidencebound, col = col,
            add = TRUE, drawlabels = T, lty = lty, lwd = lwd,
            labels = labels)
  }
}



plot_mdist_pow<-function(ECP_obj,alp=0.05, OMind = 1:48,
                         Iind=NULL,yind=1:6,powind=1,
                         byyr=F,add=F,labs=T,res=T, ploty=T){

  if(is.null(Iind))Iind=ECP_obj$Defaults$Data

  if(!byyr) out=get_pred_sim(ECP_obj,OMind,Iind,powind=powind)
  if(byyr) out=get_pred_sim_yr(ECP_obj,OMind,Iind,yind,powind=powind)

  preds=out$preds
  obs=out$obs
  pows=out$pows
  yrs=out$yrs

  nullcov<-cov(preds)
  nullm<-apply(preds,2,mean,na.rm=T)

  if(!byyr) dist<-mahalanobis_robust(x=obs, center=nullm, cov=nullcov)

  dists<-mahalanobis_robust(x=preds, center=nullm, cov=nullcov)

  xlim=c(min(quantile(dists,0.0005)),max(quantile(dists,0.9995)))
  if(!add)par(mfrow=c(1,1),mai=c(0.65,0.65,0.5,0.05))
  dens_null<-density(dists[!pows],from=0,to=xlim[2])
  dens_alt<-density(dists[pows],from=0,to=xlim[2])

  thresh<-quantile(dists[!pows],1-alp)
  beta<-mean(dists[pows]<thresh)*100

  if(ploty){
    ylim=c(0,max(dens_null$y,dens_alt$y))
    plot(dens_null,xlab="",main="",col='white',ylab="",xlim=xlim,ylim=ylim); grid()
    lines(dens_null,xlab="",main="",col='blue',lwd=2)
    lines(dens_alt,xlab="",main="",col='red',lwd=2)

    abline(v=thresh,lty=2,lwd=2,col="orange")
    cols = c("#0000ff95","#ff000095","white","white")

    cex = 0.85
     legend('right',legend=c(paste("Type I err = ",round(alp*100,1),"%"),
                             paste("Type II = ",round(beta,1),"%"),
                             paste("Tot Err. = ",round(beta+alp*100,1),"%"),
                             paste("Power = ",round(100-beta,1),"%")),
           fill=cols, border=cols,bty='n',cex=cex)
    legend('left',legend=c("Null","Alternate"),lwd=2,col=c("blue","red"),bty='n',cex=0.85)

    if(labs)mtext("Multivariate distance",1,line=2)
    if(labs)mtext("Density",2,line=2)


    subdens_null<-getsegment(dens_null,thresh,lower=F)
    polygon(y=subdens_null$x,x=subdens_null$y,col=cols[1],border=NA)

    subdens_alt<-getsegment(dens_alt,thresh,lower=T)
    polygon(y=subdens_alt$x,x=subdens_alt$y,col=cols[2],border=NA)

    if(!byyr){
      leg<-"Outlier detected (D > V)"
      lcol<-"purple"
      if(dist<thresh){
        leg<-"Outlier not detected (D < V)"
        lcol="darkgreen"
      }
    }

    adj = 0.07*(xlim[2]-thresh)
    text(thresh+adj,ylim[2]*0.9,"V",font=2,cex=cex,col="orange")
    if(!byyr) text(dist+adj, ylim[2]*0.97,"D",font=2,cex=cex,col=lcol)
    if(!byyr) abline(v=dist,lwd=2,col=lcol,lty=2)

    if(!byyr){
       legend('topleft',legend=c(paste0("Crit. value = ",round(thresh,2)),
                              paste0("Test stat. = ",round(dist,2))),
           text.col=c('orange',lcol),cex=cex,bty='n')
    }else{
      legend('topleft',legend=paste0("Crit. value = ",round(thresh,2)),
                                text.col=c('orange'),cex=cex,bty='n')
    }

    legend('topright',legend=c(paste("n data =",ncol(preds)),paste("Yrs:",min(yrs),"-",max(yrs))),
           bty='n',cex=cex)
    if(!byyr&res)mtext(leg,col=lcol,3,line=0.2,font=2)
  } # end of if ploty

  c(alp = alp*100, beta = beta, pow = 100-beta, toterr = beta+alp*100)
}


optE_int = function(par,dists,pows,opt=T){
  alp = exp(par)/(1+exp(par))
  thresh<-quantile(dists[!pows],1-alp)
  beta<-mean(dists[pows]<thresh)
  if(opt)return((alp-beta)^2)
  if(!opt)return(c(alp,beta))
}


optimE<-function(ECP_obj,OMind = 1:48, Iind=NULL,yind=1:6,powind=1,byyr=F){

  if(is.null(Iind))Iind=ECP_obj$Defaults$Data
  if(!byyr) out=get_pred_sim(ECP_obj,OMind,Iind,powind=powind)
  if(byyr) out=get_pred_sim_yr(ECP_obj,OMind,Iind,yind, powind=powind)

  preds=out$preds
  obs=out$obs
  pows=out$pows
  yrs=out$yrs

  nullcov<-cov(preds)
  nullm<-apply(preds,2,mean,na.rm=T)
  dists<-mahalanobis_robust(x=preds, center=nullm, cov=nullcov)

  opt=optimize(optE_int,interval=c(-4,4),dists=dists, pows=pows)
  optE_int(opt$minimum,dists=dists, pows=pows, opt=F)

}


plot_CC<-function(ECP_obj,quanty=0.5,ptcex=0.6,maxn=10,OMind=1:48, Iind=NULL,powind=1,dopow=F){

  if(is.null(Iind))Iind=ECP_obj$Defaults$Data

  out=get_pred_sim(ECP_obj,OMind,Iind,powind)
  preds=out$preds
  obs=out$obs
  nams=out$nams
  pows=out$pows
  ndat = dim(preds)[2]
  ni <- min(ndat,maxn)
  cols<-c("#0000ff15","black","#ff000045")
  par(mfrow=c(ni-1,ni-1),mai=rep(0,4),omi=c(0.55,0.75,0.05,0.05))
  cutoff= c(quanty/100,(100-quanty)/100)

  for(i in 2:ni){

    for(j in 1:(ni-1)){

      if(j==i|j>i){

        plot(1,1,col='white',axes=F)

      }else{

        xlim<-range(quantile(preds[,j],cutoff,na.rm=T),obs[j])
        ylim<-range(quantile(preds[,i],cutoff,na.rm=T),obs[i])

        if(!dopow){
          plot(preds[,j],preds[,i],pch=19,xlim=xlim,ylim=ylim,cex=ptcex,col=cols[1],axes=F)
        }else{
          plot(preds[!pows,j],preds[!pows,i],pch=19,xlim=xlim,ylim=ylim,cex=ptcex,col=cols[1],axes=F)
          points(preds[pows,j],preds[pows,i],pch=19,cex=ptcex,col=cols[3])
        }

        axis(1,c(-100,100))
        axis(2,c(-100,100))
        axis(3,c(-100,100))
        axis(4,c(-100,100))
        points(obs[j],obs[i],pch=19,cex=1.2,col=cols[2])

      }
      if(i==2&j==(ni-1)){
        legend('center',legend=c("Obs","Sim"),text.col=c("black","blue"),bty='n')

      }

      if(j==1)mtext(nams[i],2,line=2,cex=0.6,las=2)
      if(i==ni)mtext(nams[j],1,line=1,cex=0.6,las=2)
      #if(j==1)mtext(i,2,line=2,cex=0.5,las=2)
      #if(i==nplotted)mtext(j,1,line=1,cex=0.5,las=2)

    }

  }

}



# power analysis versions

PPD_qplot_pow = function(qs_null,qs_alt, Obs, Yrs, cols,line,plotcrit){

  ylim = range(qs_null,qs_alt,Obs,na.rm=T)
  matplot(Yrs,t(qs_null),col="white",ylim=ylim,xlab="",ylab="");  grid()
  nq = nrow(qs_null)

  if(!line){
    keep=!is.na(qs_null[1,])
    for(i in 1:(nq/2))  polygon(c(Yrs[keep],rev(Yrs[keep])),c(qs_null[i,keep],rev(qs_null[nq-i+1,keep])),col=cols[1],border=NA)
    keep=!is.na(qs_alt[1,])
    for(i in 1:(nq/2))  polygon(c(Yrs[keep],rev(Yrs[keep])),c(qs_alt[i,keep],rev(qs_alt[nq-i+1,keep])),col=cols[2],border=NA)
  }else{

    keep=!is.na(qs_null[1,])
    for(i in (nq/2))  polygon(c(Yrs[keep],rev(Yrs[keep])),c(qs_null[i,keep],rev(qs_null[nq-i+1,keep])),col=cols[1],border=NA)
    keep=!is.na(qs_alt[1,])
    for(i in (nq/2))  polygon(c(Yrs[keep],rev(Yrs[keep])),c(qs_alt[i,keep],rev(qs_alt[nq-i+1,keep])),col=cols[2],border=NA)

    for(i in 1){
      keep=!is.na(qs_null[1,])
      lines(Yrs[keep],qs_null[i,keep],col="blue",lwd=1)
      lines(Yrs[keep],qs_null[nq-i+1,keep],col="blue",lwd=1)
      keep=!is.na(qs_alt[1,])
      lines(Yrs[keep],qs_alt[i,keep],col="red",lwd=1)
      lines(Yrs[keep],qs_alt[nq-i+1,keep],col="red",lwd=1)
    }
  }
  if(!is.null(plotcrit))lines(Yrs[keep],qs_null[plotcrit,keep])

  points(Yrs,Obs,pch=19)

}



PPD_Proj_pow = function(ECP_obj, Iplot = 1, OMind = 1:48, yind = 1:9,powind=1,cols,line,plotcrit){

  PPDnull = PPDalt = ECP_obj$PPD
  ints = c(99,95,90,50)
  lps = ((100-ints)/2)/100
  ps = c(lps, rev(1-lps))

  powSwitch = array(ECP_obj$Pow[,,powind],dim(PPDnull))

  PPDnull[powSwitch]=NA
  PPDalt[!powSwitch]=NA

  qs_null = apply(PPDnull[,OMind,Iplot,yind,drop=F],4,quantile,p=ps,na.rm=T)
  qs_alt = apply(PPDalt[,OMind,Iplot,yind,drop=F],4,quantile,p=ps,na.rm=T)

  Yrs = ECP_obj$First_Yr-1+yind
  Obs = ECP_obj$Obs[Iplot,yind]

  PPD_qplot_pow(qs_null,qs_alt, Obs, Yrs,cols=cols,line=line,plotcrit=plotcrit)
  mtext(dimnames(PPDnull)[[3]][Iplot],line=0.4,font=2,cex=0.85)

}


plot_marg_dens_pow=function(ECP_obj,OMind=1:48, Iind=NULL,yind=1:7,
                            powind=2,cols=c("#0000ff20","#ff000020"),line=F,plotcrit=2){

  if(is.null(Iind))Iind=ECP_obj$Defaults$Data
  ni = length(Iind)+1
  nr=ceiling(ni^0.5)
  nc=ceiling(ni/nr)
  par(mfrow=c(nr,nc),mai=c(0.3,0.3,0.35,0.025),omi=c(0.3,0.3,0,0))

  for(i in 1:(ni-1))    PPD_Proj_pow(ECP_obj, Iplot = Iind[i], OMind = OMind, yind = yind,powind=powind,cols=cols,line=line,plotcrit=plotcrit)
  for(i in 1:((nr*nc)-ni+1))plot(1,1,col="white",xlab="",ylab="",axes=F,main="")
  coly = paste0("#0000ff",c(20,30,40,80))
  colyp = paste0("#ff0000",c(20,30,40,80))

  legend('left',fill = coly,cex=1.1,legend = c("99%","95%","90%","50%"),title = "Null", bty='n',border=coly)
  legend('right',fill = colyp,cex=1.1,legend = c("99%","95%","90%","50%"),title = "Alt", bty='n',border=colyp)
  mtext('Year',1,line=0.5,outer=T,font=2)
  mtext('Index value',2,line=0.5,outer=T,font=2)
}


pcalc = function(qsa,PPDn,PPDa,tail,qsa2=NULL){

  if(tail=="LB"){
    T1 = mean(apply(PPDn<qsa,1:2,sum)>0,na.rm=T)
    T2 = 1-mean(apply(PPDa<qsa,1:2,sum)>0,na.rm=T) # all indices have to not have been triggered
  }else if(tail=="UB"){
    T1 = mean(apply(PPDn>qsa,1:2,sum)>0,na.rm=T)
    T2 = 1-mean(apply(PPDa>qsa,1:2,sum)>0,na.rm=T) # all indices have to not have been triggered
  }else{
    T1 = mean(apply(PPDn<qsa | PPDn>qsa2 ,1:2,sum),na.rm=T)
    T2 = 1-mean(apply(PPDa<qsa | PPDa>qsa2 ,1:2,sum),na.rm=T) # all indices have to not have been triggered
  }

  c(T1=T1,T2=T2)

}

pcalc2 = function(PPDn,PPDa,alp,tail){

  ni = dim(PPDn)[3]
  erri = rep(NA,ni)

  trig1 = array(FALSE, dim(PPDn)[1:2])
  #trig1[is.na(PPDn[,,1,1])]=NA

  trig2 = array(0,  dim(PPDn)[1:2]) # issue is here
  trig2[is.na(PPDa[,,1,1])]=NA

  for(i in 1:ni){
    if(tail[i]=="LB"){

      crit = quantile(PPDn[,,i,1],alp,na.rm=T)
      trig1[] = trig1[] | (PPDn[,,i,1]<crit)
      trig2[] = trig2[] + as.integer(PPDa[,,i,1]<crit)

    }else if(tail[i]=="UB"){

      crit = quantile(PPDn[,,i,1],1-alp,na.rm=T)
      trig1[] = trig1[] | (PPDn[,,i,1]>crit)
      trig2[] = trig2[] + as.integer(PPDa[,,i,1]>crit)

    }else{

      critLB = quantile(PPDn[,,i,1],alp/2,na.rm=T)
      critUB = quantile(PPDn[,,i,1],1-(alp/2),na.rm=T)
      trig1[] = trig1[] | ((PPDn[,,i,1] < critLB) | (PPDn[,,i,1] > critUB))
      if(i > 1) trig2[] = trig2[] + as.integer(((PPDa[,,i,1] < critLB) & (PPDa[,,i,1] > critUB)))

    }

  }
  trig2c = trig2 == 0

  c(mean(trig1,na.rm=T),mean(trig2c,na.rm=T))

}


plot_Err = function(Err,Iind){

  Err2=Err
  Err2[1,]=1-Err[1,]
  Err2[is.na(Err2)]=1
  Err3=1-apply(Err2,1,cumprod)# total Type I error/ power

  ys = colnames(Err)
  par(mfrow=c(1,2),mai=c(0.4,0.4,0.05,0.05),omi=c(0.4,0.4,0.3,0.01))
  matplot(ys,t(Err),col="white",lty=1,type="l",xlab="",ylab="",ylim=c(0,1))
  grid()
  matplot(ys,t(Err),col=c("blue","red"),lty=1,type="l",add=T)
  legend('topright',legend=c("Type I","Type II"),text.col=c("blue","red"),bty="n")

  matplot(ys,Err3,col="white",lty=1,type="l",xlab="",ylab="",ylim=c(0,1))
  grid()
  matplot(ys,Err3,col=c("blue","red"),lty=1,type="l",add=T)
  legend('topleft',legend=c("Cumu. Type I","Cumu. Power"),text.col=c("blue","red"),bty="n")
  mtext("Rate",side=2,line=0.5,outer=T)
  mtext("Year",side=1,line=0.5,outer=T)
  mtext(paste0("I = ",paste(Iind,collapse=","),"; Pow = ",powind,"; alpha =",alp),line=0.15,outer=T)

}

# What if we ran it through all the years
Seq_Pow_Calc_Marg = function(ECP_obj, OMind = 1:48, Iind=NULL, yind=1:8, powind=1, alp=0.025, tail = "LB",plot=T){

  if(length(tail)==1)tail=rep(tail,length(Iind))
  if(is.null(Iind))Iind=ECP_obj$Defaults$Data

  PPD = PPDalt = PPDnull = ECP_obj$PPD[,OMind,Iind,yind,drop=F]
  pow = ECP_obj$Pow[,OMind,powind]
  nsim=dim(PPD)[1]
  ystodo = yind[apply(PPD,4,function(x){length(unique(as.vector(x)))>(nsim-1)})]
  Yrs = ECP_obj$First_Yr-1+yind
  Obs = ECP_obj$Obs[Iind,yind]
  qs=apply(PPD[,,,yind],3,quantile,p=1-alp,na.rm=T)


  if(plot) plot(c(min(Yrs),max(Yrs)+1),c(0,1.05),col='white',xlab="",ylab="")
  dims=dim(PPD)
  nsim=dims[1]
  ny = dims[4]
  nOM = dims[2]

  nI = length(Iind)
  Err = array(NA,c(2,ny))
  rownames(Err) = c("Type I","Type II")
  colnames(Err) = colnames(ECP_obj$Obs)[1:max(ystodo)]

  powSwitch = array(pow,dim(PPD))
  PPDnull[powSwitch]=NA
  PPDalt[!powSwitch]=NA
  #qst = array(NA,c(nI,ny))

  #if(!tail%in%c("LB","UB"))qst=array(NA,c(2,nI,ny))
  for(yy in ystodo){
    PPDn=PPDnull[,,,yy,drop=F]
    PPDa=PPDalt[,,,yy,drop=F]
    Err[,yy] = pcalc2(PPDn, PPDa, alp, tail)
  }

  if(plot)plot_Err(Err,Iind)
  Err
}

codegone<-function(){
  if(tail == "LB"){
    qs=apply(PPDnull[,,,yy,drop=F],3,quantile,p=alp,na.rm=T)
    qst[,yy]= qs
    qsa = array(rep(qs,each=nsim*nOM),c(nsim,nOM,nI,1))
    Err[,yy] = pcalc(qsa,PPDn,PPDa,tail)

  }else if(tail == "UB"){
    qs=apply(PPD[,,,yy,drop=F],3,quantile,p=1-alp,na.rm=T)
    qst[,yy]= qs
    qsa = array(rep(qs,each=nsim*nOM),c(nsim,nOM,nI,1))
    Err[,yy] = pcalc(qsa,PPDn,PPDa,tail)

  }else{
    qs=apply(PPD[,,,yy,drop=F],3,quantile,p=c(alp/2,1-(alp/2)),na.rm=T)
    qst[,,yy]= qs
    qsa = array(rep(qs[1,],each=nsim*nOM),c(nsim,nOM,nI))
    qsa2 = array(rep(qs[2,],each=nsim*nOM),c(nsim,nOM,nI))
    Err[,yy] = pcalc(qsa,PPDn,PPDa,tail,qsa2=qsa2)
  }
}

Seq_Pow_Calc_MV=function(ECP_obj, OMind = 1:48, Iind=NULL, yind=1:8, powind=1, alp=0.025, LB=FALSE){

  if(is.null(Iind))Iind=ECP_obj$Defaults$Data

  ny = length(yind)
  nI = length(Iind)
  PPD = ECP_obj$PPD[,OMind,Iind,yind,drop=F]
  #pows = ECP_obj$Pow[,OMind,powind]
  nsim=dim(PPD)[1]
  ystodo = yind[apply(PPD,4,function(x){length(unique(as.vector(x)))>(nsim-1)})]
  Err = array(NA,c(2,ny))
  rownames(Err) = c("Type I","Type II")
  colnames(Err) = colnames(ECP_obj$Obs)[1:max(ystodo)]

  for(yub in ystodo){

    yvind = 1:yub
    out=get_pred_sim_yr(ECP_obj,OMind,Iind,yind=yvind,powind=powind)
    preds=out$preds
    obs=out$obs
    pows=out$pows
    yrs=out$yrs
    nullcov<-cov(preds)
    nullm<-apply(preds,2,mean,na.rm=T)
    dists<-mahalanobis_robust(x=preds, center=nullm, cov=nullcov)
    alp2 = alp

    if(LB){ # if joint LB
      up = preds>array(rep(nullm,each=nrow(preds)),dim(preds))
      jointUB = apply(up,1,all)
      dists[jointUB] = NA
      fracLB = mean(!jointUB)
      alp2 = alp/fracLB
    }

    thresh<-quantile(dists[!pows],1-alp2,na.rm=T)
    Err[1,yub] = alp #mean(dists[!pows]>thresh,na.rm=T)
    Err[2,yub] = mean(dists[pows]<thresh,na.rm=T)

  }

  plot_Err(Err,Iind)
  Err

}

dohelp = function(alp_rng){
  ahigh = alp_rng[1]+(alp_rng[2]-alp_rng[1])*0.9
  text(ahigh,-0.02,"BETTER",font=2,col="#0000ff20")
  arrows(ahigh,0.07,ahigh,0.01,col="#0000ff20",lwd=2,length=0.1)
  text(ahigh,1.02,"BETTER",font=2,col="#ff000020",cex=0.9)
  arrows(ahigh,0.93,ahigh,0.99,col="#ff000020",lwd=2,length=0.1)
}

EPTO = function(ECPobj,OMind = 1:48, Iind=NULL, yind=1:8, powind=1, tail = "LB",
                alp_rng = c(0.001,0.05),res = 20,ys=c(3,6), plot=T){

  nys=length(ys)
  errarr = array(NA,c(nys,res,2))

  as = seq(alp_rng[1], alp_rng[2], length.out=res)
  for(i in 1:res){

    Err = Seq_Pow_Calc_Marg(ECP_obj, OMind = OMind, Iind=Iind, yind=yind, powind=powind, alp=as[i], tail = tail,plot=F)
    Err2=Err
    Err2[1,]=1-Err[1,]
    Err2[is.na(Err2)]=1
    Err3=1-apply(Err2,1,cumprod)# total Type I error/ power
    errarr[,i,] = Err3[ys,]

  }

  if(plot){
    par(mfrow=c(1,2),mai=c(0.3,0.5,0.3,0.01),omi=c(0.5,0.3,0.01,0.01))
    for(i in 1:nys){
      plot(alp_rng,c(0,1),col="white")
      grid()
      matplot(as,errarr[i,,],type="l",col=c("blue","red"),add=T,lty=1)
      mtext(paste("Projection year",ys[i]),line=0.4)
      if(i==1)legend('topleft',legend=c("Cml. Type I Err.","Cml. Power"),text.col=c("blue","red"),bty='n')
      dohelp(alp_rng)

    }

    mtext("Per index Type I error",1,outer=T,line=0.9)
    mtext("Cumulative Type I error / Power",2,outer=T,line=0.2)
  }

  errarr

}

autotail=function(ECP_obj, OMind, Iind, yind, powind){

  PPD = PPDalt = PPDnull = ECP_obj$PPD[,OMind,Iind,yind,drop=F]
  nsim=dim(PPD)[1]
  ystona = yind[apply(PPD,4,function(x){length(unique(as.vector(x)))<(nsim-1)})]

  pow = ECP_obj$Pow[,OMind,powind]
  powSwitch = array(pow,dim(PPD))
  PPDnull[powSwitch]=NA
  PPDalt[!powSwitch]=NA
  PPDnull[,,,ystona] = NA
  PPDalt[,,,ystona]=NA
  mu_null=apply(PPDnull,3:4,mean,na.rm=T)
  mu_alt = apply(PPDalt,3:4,mean,na.rm=T)

  sums = apply(mu_alt > mu_null,1,mean,na.rm=T)
  c("LB","UB")[1+as.integer(sums>0.5)]

}

Brute_find = function(ECP_obj, OMind, Iind, yind, powind, tail, targ_cml_alp = 0.2, yr=3){

  ni = length(Iind)
  perms = expand.grid(rep(list(c(T,F)),ni))
  np = nrow(perms)

  findpow = function(x,perms,ECP_obj, OMind, Iind, yind, powind, tail, targ_cml_alp = 0.1,yr){
    incvec = unlist(perms[x,])
    errmat=EPTO(ECP_obj, OMind, Iind[incvec], yind, powind, tail[incvec], alp_rng = c(0.001,0.05),ys=c(yr,6),plot=F)
    t1s =  errmat[1,,1]
    pows = errmat[1,,2]
    approx(t1s,pows,targ_cml_alp)$y
  }

  pows = sapply(1:10,findpow,perms=perms,ECP_obj=ECP_obj, OMind=OMind, Iind=Iind, yind=yind, powind=powind, tail=tail, targ_cml_alp = 0.1)

  sfInit(parallel=T,cpus=7)
  sfExport(list=list('perms',"ECP_obj",'OMind','Iind','yind','powind','tail','targ_cml_alp','EPTO','Seq_Pow_Calc_Marg','yr','pcalc2'))
  pows = sfSapply(1:np,findpow,perms=perms,ECP_obj=ECP_obj, OMind=OMind, Iind=Iind, yind=yind, powind=powind, tail=tail, targ_cml_alp = 0.1)


}
